/**
 * Agravity OpenAPI Documentation - Private Functions
 * <h1>Agravity API Reference</h1>This is the full API description of Agravity GmbH.<br/><h2>Resources</h2><ul> <li>Collection type management</li> <li>Collections management</li> <li>Assets management</li> <li>Assets operations</li> <li>Assets publishing</li> <li>Assets versioning</li> <li>Sharing collection</li> <li>Secure upload to collection</li> <li>Download ZIP</li> <li>Search</li> <li>General management</li> <li>Authentication management</li> <li>Blob management</li> <li>Queue management</li> <li>Structure management</li> <li>Bulk get all data from collection / collection type</li></ul><h2> Operations</h2>Agravity API performs the following operations:<ul> <li>Create / update / list / delete collection types</li> <li>Create / update / list / delete collections</li> <li>Create / update / list / delete assets</li> <li>Operations on assets like: move to collection, renew asset(through queue pipe), rotate, resize, etc.</li> <li>Publish / de-publish an asset or specific variants of an asset</li> <li>Create / delete version of asset</li> <li>Bulk download of Assets</li> <li>Search for assets or collections</li> <li>Authenticated access like e.g. getting access to blobs directly (for upload on folder or generate SAS token)</li> <li>List / delete blobs</li> <li>Create structures based on blob storage input</li></ul><br/>Copyright Â© Agravity GmbH 2023. All Rights Reserved
 *
 * The version of the OpenAPI document: 6.1.2
 * Contact: office@agravity.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent, HttpParameterCodec } from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

import { AgravityErrorResponse } from '../model/models';
import { AgravityInfoResponse } from '../model/models';
import { Asset } from '../model/models';
import { AssetBulkUpdate } from '../model/models';
import { AssetPageResult } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { AgravityConfiguration } from '../configuration';

@Injectable({
	providedIn: 'root'
})
export class AssetManagementService {
	protected basePath = 'http://localhost:7071/api';
	public defaultHeaders = new HttpHeaders();
	public configuration = new AgravityConfiguration();
	public encoder: HttpParameterCodec;

	constructor(
		protected httpClient: HttpClient,
		@Optional() @Inject(BASE_PATH) basePath: string,
		@Optional() configuration: AgravityConfiguration
	) {
		if (configuration) {
			this.configuration = configuration;
		}
		if (typeof this.configuration.basePath !== 'string') {
			if (typeof basePath !== 'string') {
				basePath = this.basePath;
			}
			this.configuration.basePath = basePath;
		}
		this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
	}

	/**
	 * @param consumes string[] mime-types
	 * @return true: consumes contains 'multipart/form-data', false: otherwise
	 */
	private canConsumeForm(consumes: string[]): boolean {
		const form = 'multipart/form-data';
		for (const consume of consumes) {
			if (form === consume) {
				return true;
			}
		}
		return false;
	}

	private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
		if (typeof value === 'object' && value instanceof Date === false) {
			httpParams = this.addToHttpParamsRecursive(httpParams, value);
		} else {
			httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
		}
		return httpParams;
	}

	private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
		if (value == null) {
			return httpParams;
		}

		if (typeof value === 'object') {
			if (Array.isArray(value)) {
				(value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
			} else if (value instanceof Date) {
				if (key != null) {
					httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
				} else {
					throw Error('key may not be null if value is Date');
				}
			} else {
				Object.keys(value).forEach((k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k)));
			}
		} else if (key != null) {
			httpParams = httpParams.append(key, value);
		} else {
			throw Error('key may not be null if value is not object or array');
		}
		return httpParams;
	}

	/**
	 * This endpoint allows to upload one asset which is put onto the storage (INBOX). Collection ID is mandatory on asset upload. Previewof can be used alone.
	 * @param name
	 * @param collectionId
	 * @param file
	 * @param filename
	 * @param previewof
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetUploadFile(
		name?: string,
		collectionId?: string,
		file?: Blob,
		filename?: string,
		previewof?: string,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<Asset>;
	public httpAssetUploadFile(
		name?: string,
		collectionId?: string,
		file?: Blob,
		filename?: string,
		previewof?: string,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetUploadFile(
		name?: string,
		collectionId?: string,
		file?: Blob,
		filename?: string,
		previewof?: string,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetUploadFile(
		name?: string,
		collectionId?: string,
		file?: Blob,
		filename?: string,
		previewof?: string,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		let headers = this.defaultHeaders;

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['multipart/form-data'];

		const canConsumeForm = this.canConsumeForm(consumes);

		let formParams: { append(param: string, value: any): any };
		let useForm = false;
		let convertFormParamsToString = false;
		// use FormData to transmit files using content-type "multipart/form-data"
		// see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
		useForm = canConsumeForm;
		if (useForm) {
			formParams = new FormData();
		} else {
			formParams = new HttpParams({ encoder: this.encoder });
		}

		if (name !== undefined) {
			formParams = (formParams.append('name', <any>name) as any) || formParams;
		}
		if (collectionId !== undefined) {
			formParams = (formParams.append('collectionId', <any>collectionId) as any) || formParams;
		}
		if (file !== undefined) {
			formParams = (formParams.append('file', <any>file) as any) || formParams;
		}
		if (filename !== undefined) {
			formParams = (formParams.append('filename', <any>filename) as any) || formParams;
		}
		if (previewof !== undefined) {
			formParams = (formParams.append('previewof', <any>previewof) as any) || formParams;
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assetsupload`, convertFormParamsToString ? formParams.toString() : formParams, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param assetBulkUpdate The body has to be valid json which contains the reference asset, which for which collection (reference for collection type items) and which assets are to update. The containing keywords (tags) will be removed. Only custom values are replaces if they are part of the given collection id.
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkDeleteUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AgravityInfoResponse>;
	public httpAssetsBulkDeleteUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkDeleteUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkDeleteUpdate(assetBulkUpdate: AssetBulkUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkDeleteUpdate.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress,
			body: assetBulkUpdate
		});
	}

	/**
	 * @param assetBulkUpdate The body has to be valid json which contains the reference asset, which for which collection (reference for collection type items) and which assets are to update. The containing keywords (tags) will be distinctly added (no removal). Only custom values are replaces if they are part of the given collection id.
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkPostUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AgravityInfoResponse>;
	public httpAssetsBulkPostUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkPostUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkPostUpdate(assetBulkUpdate: AssetBulkUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkPostUpdate.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, assetBulkUpdate, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param assetBulkUpdate The body has to be valid json which contains the reference asset, a collection (used as reference for collection type items) and which asset ids are to update. The containing keywords (tags) will be fully replaced. ONLY custom items are replaced which are in body (others in same collection will be ignored)!Only custom values are replaces if they are part of the given collection id.
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkPutUpdate(assetBulkUpdate: AssetBulkUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<AgravityInfoResponse>;
	public httpAssetsBulkPutUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkPutUpdate(
		assetBulkUpdate: AssetBulkUpdate,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkPutUpdate(assetBulkUpdate: AssetBulkUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkPutUpdate.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.put<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, assetBulkUpdate, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint creates one asset entry in the database.
	 * @param collectionid The ID of the collection where this assets should be assigned.
	 * @param asset This endpoint creates an unique asset ID and adds the information to the database.
	 * @param translations When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header)
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsCreate(
		collectionid: string,
		asset: Asset,
		translations?: boolean,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<Asset>;
	public httpAssetsCreate(
		collectionid: string,
		asset: Asset,
		translations?: boolean,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsCreate(
		collectionid: string,
		asset: Asset,
		translations?: boolean,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsCreate(
		collectionid: string,
		asset: Asset,
		translations?: boolean,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		if (collectionid === null || collectionid === undefined) {
			throw new Error('Required parameter collectionid was null or undefined when calling httpAssetsCreate.');
		}
		if (asset === null || asset === undefined) {
			throw new Error('Required parameter asset was null or undefined when calling httpAssetsCreate.');
		}

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (collectionid !== undefined && collectionid !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>collectionid, 'collectionid');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assets`, asset, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param filter The filter of assets
	 * @param collectionId The ID of the collection.
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsDeleteAll(filter: string, collectionId: string, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<any>;
	public httpAssetsDeleteAll(
		filter: string,
		collectionId: string,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<any>>;
	public httpAssetsDeleteAll(filter: string, collectionId: string, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<HttpEvent<any>>;
	public httpAssetsDeleteAll(filter: string, collectionId: string, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		if (filter === null || filter === undefined) {
			throw new Error('Required parameter filter was null or undefined when calling httpAssetsDeleteAll.');
		}
		if (collectionId === null || collectionId === undefined) {
			throw new Error('Required parameter collectionId was null or undefined when calling httpAssetsDeleteAll.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<any>(`${this.configuration.basePath}/assets`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param id The ID of the asset.
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsDeleteById(id: string, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<any>;
	public httpAssetsDeleteById(id: string, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<HttpResponse<any>>;
	public httpAssetsDeleteById(id: string, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<HttpEvent<any>>;
	public httpAssetsDeleteById(id: string, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsDeleteById.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<any>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param collectionid The ID of the collection where these assets should come from. (\&quot;empty\&quot; is allowed)
	 * @param fields This limits the fields which are returned, separated by comma (\&#39;,\&#39;). Blobs can be limited with \&#39;.\&#39; on their container. (i.e. fields&#x3D;blobs.thumbnails). Only if \&#39;thumbnails\&#39; is set, the placeholder of this asset type are returned if no thumbnail blob is found.
	 * @param expose This indicates if the given blobs should have URLs where these can be requested. (If not limited through \&#39;fields\&#39; parameter it will expose all URLs of all blobs.)
	 * @param continuationToken Each result returns the continous token if more results are available than requested. With this token, the next page could be fetched. (URL encoded!)
	 * @param limit This number limits the page result of assets.
	 * @param orderby How the return assets are sorted. Default is property: created_date (newest first).
	 * @param filter This will limit the output on specific parameters which are separated by \&#39;:\&#39;, \&#39;!:\&#39;, \&#39;&gt;\&#39;, \&#39;&gt;&#x3D;\&#39;, \&#39;&lt;\&#39;, \&#39;&lt;&#x3D;\&#39;
	 * @param items The items can be extended to fully filled items.
	 * @param translations When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header)
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsGet(
		collectionid?: string,
		fields?: string,
		expose?: boolean,
		continuationToken?: string,
		limit?: number,
		orderby?: string,
		filter?: string,
		items?: boolean,
		translations?: boolean,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AssetPageResult>;
	public httpAssetsGet(
		collectionid?: string,
		fields?: string,
		expose?: boolean,
		continuationToken?: string,
		limit?: number,
		orderby?: string,
		filter?: string,
		items?: boolean,
		translations?: boolean,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AssetPageResult>>;
	public httpAssetsGet(
		collectionid?: string,
		fields?: string,
		expose?: boolean,
		continuationToken?: string,
		limit?: number,
		orderby?: string,
		filter?: string,
		items?: boolean,
		translations?: boolean,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AssetPageResult>>;
	public httpAssetsGet(
		collectionid?: string,
		fields?: string,
		expose?: boolean,
		continuationToken?: string,
		limit?: number,
		orderby?: string,
		filter?: string,
		items?: boolean,
		translations?: boolean,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (collectionid !== undefined && collectionid !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>collectionid, 'collectionid');
		}
		if (fields !== undefined && fields !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>fields, 'fields');
		}
		if (expose !== undefined && expose !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>expose, 'expose');
		}
		if (continuationToken !== undefined && continuationToken !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>continuationToken, 'continuation_token');
		}
		if (limit !== undefined && limit !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>limit, 'limit');
		}
		if (orderby !== undefined && orderby !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>orderby, 'orderby');
		}
		if (filter !== undefined && filter !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>filter, 'filter');
		}
		if (items !== undefined && items !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>items, 'items');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.get<AssetPageResult>(`${this.configuration.basePath}/assets`, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint returns one single asset (from ID). If the returned asset is from a special asset type (e.g. \&quot;AssetImage\&quot;) it returns the full entity.
	 * @param id The ID of the asset.
	 * @param fields Which fields are need to be filled out with comma separated. If one is set all non mandatory fields are left out. No validation if field exist.
	 * @param expose This indicates if the given blobs should have URLs where these can be requested. It will expose placeholder blobs if no \&#39;thumbnail\&#39; is found.)
	 * @param items The items can be extended to fully filled items.
	 * @param translations When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header)
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsGetById(
		id: string,
		fields?: string,
		expose?: boolean,
		items?: boolean,
		translations?: boolean,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<Asset>;
	public httpAssetsGetById(
		id: string,
		fields?: string,
		expose?: boolean,
		items?: boolean,
		translations?: boolean,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsGetById(
		id: string,
		fields?: string,
		expose?: boolean,
		items?: boolean,
		translations?: boolean,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsGetById(
		id: string,
		fields?: string,
		expose?: boolean,
		items?: boolean,
		translations?: boolean,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsGetById.');
		}

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (fields !== undefined && fields !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>fields, 'fields');
		}
		if (expose !== undefined && expose !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>expose, 'expose');
		}
		if (items !== undefined && items !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>items, 'items');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.get<Asset>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint updates one single asset (from ID)
	 * @param id The ID of the asset.
	 * @param asset The body has to contain one of the mentioned elements and a valid json. Not fitting properties are ignored.
	 * @param translations When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header)
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsUpdateById(id: string, asset: Asset, translations?: boolean, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<Asset>;
	public httpAssetsUpdateById(
		id: string,
		asset: Asset,
		translations?: boolean,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsUpdateById(
		id: string,
		asset: Asset,
		translations?: boolean,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsUpdateById(
		id: string,
		asset: Asset,
		translations?: boolean,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsUpdateById.');
		}
		if (asset === null || asset === undefined) {
			throw new Error('Required parameter asset was null or undefined when calling httpAssetsUpdateById.');
		}

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, asset, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}
}
