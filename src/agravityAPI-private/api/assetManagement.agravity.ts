/**
 * Agravity OpenAPI Documentation - Private Functions
 * <h1>Agravity API Reference</h1>This is the full API description of Agravity GmbH.<br/><h2>Resources</h2><ul> <li>Collection type management</li> <li>Collections management</li> <li>Assets management</li> <li>Assets operations</li> <li>Assets publishing</li> <li>Assets versioning</li> <li>Sharing collection</li> <li>Secure upload to collection</li> <li>Download ZIP</li> <li>Search</li> <li>General management</li> <li>Authentication management</li> <li>Blob management</li> <li>Queue management</li> <li>Structure management</li> <li>Bulk get all data from collection / collection type</li></ul><h2> Operations</h2>Agravity API performs the following operations:<ul> <li>Create / update / list / delete collection types</li> <li>Create / update / list / delete collections</li> <li>Create / update / list / delete assets</li> <li>Operations on assets like: move to collection, renew asset(through queue pipe), rotate, resize, etc.</li> <li>Publish / de-publish an asset or specific variants of an asset</li> <li>Create / delete version of asset</li> <li>Bulk download of Assets</li> <li>Search for assets or collections</li> <li>Authenticated access like e.g. getting access to blobs directly (for upload on folder or generate SAS token)</li> <li>List / delete blobs</li> <li>Create structures based on blob storage input</li></ul><br/>Copyright Â© Agravity GmbH 2024. All Rights Reserved
 *
 * The version of the OpenAPI document: 7.3.1
 * Contact: office@agravity.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent, HttpParameterCodec } from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

import { AgravityErrorResponse } from '../model/models';
import { AgravityInfoResponse } from '../model/models';
import { Asset } from '../model/models';
import { AssetBulkUpdate } from '../model/models';
import { AssetPageResult } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { AgravityConfiguration } from '../configuration';

export interface HttpAssetUploadFileRequestParams {
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
	name?: string;
	collectionId?: string;
	file?: Blob;
	filename?: string;
	previewof?: string;
}

export interface HttpAssetsBulkDeleteUpdateRequestParams {
	/** The body has to be valid json which contains the reference asset, which for which collection (reference for collection type items) and which assets are to update. The containing keywords (tags) will be removed. Only custom values are replaces if they are part of the given collection id. */
	assetBulkUpdate: AssetBulkUpdate;
}

export interface HttpAssetsBulkPostUpdateRequestParams {
	/** The body has to be valid json which contains the reference asset, which for which collection (reference for collection type items) and which assets are to update. The containing keywords (tags) will be distinctly added (no removal). Only custom values are replaces if they are part of the given collection id. */
	assetBulkUpdate: AssetBulkUpdate;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

export interface HttpAssetsBulkPutUpdateRequestParams {
	/** The body has to be valid json which contains the reference asset, a collection (used as reference for collection type items) and which asset ids are to update. The containing keywords (tags) will be fully replaced. ONLY custom items are replaced which are in body (others in same collection will be ignored)!Only custom values are replaces if they are part of the given collection id. */
	assetBulkUpdate: AssetBulkUpdate;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

export interface HttpAssetsCreateRequestParams {
	/** The ID of the collection where this assets should be assigned. */
	collectionid: string;
	/** This endpoint creates an unique asset ID and adds the information to the database. */
	asset: Asset;
	/** When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header) */
	translations?: boolean;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

export interface HttpAssetsDeleteAllRequestParams {
	/** The filter of assets */
	filter: string;
	/** The ID of the collection. */
	collectionId: string;
}

export interface HttpAssetsDeleteByIdRequestParams {
	/** The ID of the asset. */
	id: string;
}

export interface HttpAssetsGetRequestParams {
	/** The ID of the collection where these assets should come from. (Is not required when \&#39;collectiontypeid\&#39; is set.) */
	collectionid?: string;
	/** The ID of the collection type where these assets should come from. (Is not required when \&#39;collectionid\&#39; is set.) CAUTION: The assets returned are not distinct &#x3D;&gt; Duplicates are possible if assets are in multiple collections in this collection type! */
	collectiontypeid?: string;
	/** This limits the fields which are returned, separated by comma (\&#39;,\&#39;). Blobs can be limited with \&#39;.\&#39; on their container. (i.e. fields&#x3D;blobs.thumbnails). Only if \&#39;thumbnails\&#39; is set, the placeholder of this asset type are returned if no thumbnail blob is found. */
	fields?: string;
	/** This indicates if the given blobs should have URLs where these can be requested. (If not limited through \&#39;fields\&#39; parameter it will expose all URLs of all blobs.) */
	expose?: boolean;
	/** Each result returns the continous token if more results are available than requested. With this token, the next page could be fetched. (URL encoded!) */
	continuationToken?: string;
	/** This number limits the page result of assets. */
	limit?: number;
	/** How the return assets are sorted. Default is property: modified_date (newest first). */
	orderby?: string;
	/** This will limit the output on specific parameters which are separated by \&#39;:\&#39;, \&#39;!:\&#39;, \&#39;&gt;\&#39;, \&#39;&gt;&#x3D;\&#39;, \&#39;&lt;\&#39;, \&#39;&lt;&#x3D;\&#39; */
	filter?: string;
	/** The items can be extended to fully filled items. */
	items?: boolean;
	/** When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header) */
	translations?: boolean;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

export interface HttpAssetsGetByIdRequestParams {
	/** The ID of the asset. */
	id: string;
	/** Which fields are need to be filled out with comma separated. If one is set all non mandatory fields are left out. No validation if field exist. */
	fields?: string;
	/** This indicates if the given blobs should have URLs where these can be requested. It will expose placeholder blobs if no \&#39;thumbnail\&#39; is found.) */
	expose?: boolean;
	/** The items can be extended to fully filled items. */
	items?: boolean;
	/** When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header) */
	translations?: boolean;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

export interface HttpAssetsUpdateByIdRequestParams {
	/** The ID of the asset. */
	id: string;
	/** The body has to contain one of the mentioned elements and a valid json. Not fitting properties are ignored. */
	asset: Asset;
	/** When default language should be returned and the translation dictionary is delivered. (Ignores the \&quot;Accept-Language\&quot; header) */
	translations?: boolean;
	/** The requested language of the response. If not matching it falls back to default language. */
	acceptLanguage?: string;
}

@Injectable({
	providedIn: 'root'
})
export class AssetManagementService {
	protected basePath = 'http://localhost:7071/api';
	public defaultHeaders = new HttpHeaders();
	public configuration = new AgravityConfiguration();
	public encoder: HttpParameterCodec;

	constructor(
		protected httpClient: HttpClient,
		@Optional() @Inject(BASE_PATH) basePath: string,
		@Optional() configuration: AgravityConfiguration
	) {
		if (configuration) {
			this.configuration = configuration;
		}
		if (typeof this.configuration.basePath !== 'string') {
			if (typeof basePath !== 'string') {
				basePath = this.basePath;
			}
			this.configuration.basePath = basePath;
		}
		this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
	}

	/**
	 * @param consumes string[] mime-types
	 * @return true: consumes contains 'multipart/form-data', false: otherwise
	 */
	private canConsumeForm(consumes: string[]): boolean {
		const form = 'multipart/form-data';
		for (const consume of consumes) {
			if (form === consume) {
				return true;
			}
		}
		return false;
	}

	private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
		if (typeof value === 'object' && value instanceof Date === false) {
			httpParams = this.addToHttpParamsRecursive(httpParams, value);
		} else {
			httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
		}
		return httpParams;
	}

	private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
		if (value == null) {
			return httpParams;
		}

		if (typeof value === 'object') {
			if (Array.isArray(value)) {
				(value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
			} else if (value instanceof Date) {
				if (key != null) {
					httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
				} else {
					throw Error('key may not be null if value is Date');
				}
			} else {
				Object.keys(value).forEach((k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k)));
			}
		} else if (key != null) {
			httpParams = httpParams.append(key, value);
		} else {
			throw Error('key may not be null if value is not object or array');
		}
		return httpParams;
	}

	/**
	 * This endpoint allows to upload one asset which is put onto the storage (INBOX). Collection ID is mandatory on asset upload. Previewof can be used alone.
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetUploadFile(requestParameters: HttpAssetUploadFileRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<Asset>;
	public httpAssetUploadFile(
		requestParameters: HttpAssetUploadFileRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetUploadFile(
		requestParameters: HttpAssetUploadFileRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetUploadFile(
		requestParameters: HttpAssetUploadFileRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const acceptLanguage = requestParameters.acceptLanguage;
		const name = requestParameters.name;
		const collectionId = requestParameters.collectionId;
		const file = requestParameters.file;
		const filename = requestParameters.filename;
		const previewof = requestParameters.previewof;

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['multipart/form-data'];

		const canConsumeForm = this.canConsumeForm(consumes);

		let formParams: { append(param: string, value: any): any };
		let useForm = false;
		let convertFormParamsToString = false;
		// use FormData to transmit files using content-type "multipart/form-data"
		// see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
		useForm = canConsumeForm;
		if (useForm) {
			formParams = new FormData();
		} else {
			formParams = new HttpParams({ encoder: this.encoder });
		}

		if (name !== undefined) {
			formParams = (formParams.append('name', <any>name) as any) || formParams;
		}
		if (collectionId !== undefined) {
			formParams = (formParams.append('collectionId', <any>collectionId) as any) || formParams;
		}
		if (file !== undefined) {
			formParams = (formParams.append('file', <any>file) as any) || formParams;
		}
		if (filename !== undefined) {
			formParams = (formParams.append('filename', <any>filename) as any) || formParams;
		}
		if (previewof !== undefined) {
			formParams = (formParams.append('previewof', <any>previewof) as any) || formParams;
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assetsupload`, convertFormParamsToString ? formParams.toString() : formParams, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkDeleteUpdate(
		requestParameters: HttpAssetsBulkDeleteUpdateRequestParams,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AgravityInfoResponse>;
	public httpAssetsBulkDeleteUpdate(
		requestParameters: HttpAssetsBulkDeleteUpdateRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkDeleteUpdate(
		requestParameters: HttpAssetsBulkDeleteUpdateRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkDeleteUpdate(
		requestParameters: HttpAssetsBulkDeleteUpdateRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const assetBulkUpdate = requestParameters.assetBulkUpdate;
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkDeleteUpdate.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress,
			body: assetBulkUpdate
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkPostUpdate(
		requestParameters: HttpAssetsBulkPostUpdateRequestParams,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AgravityInfoResponse>;
	public httpAssetsBulkPostUpdate(
		requestParameters: HttpAssetsBulkPostUpdateRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkPostUpdate(
		requestParameters: HttpAssetsBulkPostUpdateRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkPostUpdate(
		requestParameters: HttpAssetsBulkPostUpdateRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const assetBulkUpdate = requestParameters.assetBulkUpdate;
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkPostUpdate.');
		}
		const acceptLanguage = requestParameters.acceptLanguage;

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, assetBulkUpdate, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsBulkPutUpdate(
		requestParameters: HttpAssetsBulkPutUpdateRequestParams,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<AgravityInfoResponse>;
	public httpAssetsBulkPutUpdate(
		requestParameters: HttpAssetsBulkPutUpdateRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AgravityInfoResponse>>;
	public httpAssetsBulkPutUpdate(
		requestParameters: HttpAssetsBulkPutUpdateRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AgravityInfoResponse>>;
	public httpAssetsBulkPutUpdate(
		requestParameters: HttpAssetsBulkPutUpdateRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const assetBulkUpdate = requestParameters.assetBulkUpdate;
		if (assetBulkUpdate === null || assetBulkUpdate === undefined) {
			throw new Error('Required parameter assetBulkUpdate was null or undefined when calling httpAssetsBulkPutUpdate.');
		}
		const acceptLanguage = requestParameters.acceptLanguage;

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.put<AgravityInfoResponse>(`${this.configuration.basePath}/assetsbulkupdate`, assetBulkUpdate, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint creates one asset entry in the database.
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsCreate(requestParameters: HttpAssetsCreateRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<Asset>;
	public httpAssetsCreate(
		requestParameters: HttpAssetsCreateRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsCreate(
		requestParameters: HttpAssetsCreateRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsCreate(
		requestParameters: HttpAssetsCreateRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const collectionid = requestParameters.collectionid;
		if (collectionid === null || collectionid === undefined) {
			throw new Error('Required parameter collectionid was null or undefined when calling httpAssetsCreate.');
		}
		const asset = requestParameters.asset;
		if (asset === null || asset === undefined) {
			throw new Error('Required parameter asset was null or undefined when calling httpAssetsCreate.');
		}
		const translations = requestParameters.translations;
		const acceptLanguage = requestParameters.acceptLanguage;

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (collectionid !== undefined && collectionid !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>collectionid, 'collectionid');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assets`, asset, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsDeleteAll(requestParameters: HttpAssetsDeleteAllRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<any>;
	public httpAssetsDeleteAll(
		requestParameters: HttpAssetsDeleteAllRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<any>>;
	public httpAssetsDeleteAll(
		requestParameters: HttpAssetsDeleteAllRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<any>>;
	public httpAssetsDeleteAll(
		requestParameters: HttpAssetsDeleteAllRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const filter = requestParameters.filter;
		if (filter === null || filter === undefined) {
			throw new Error('Required parameter filter was null or undefined when calling httpAssetsDeleteAll.');
		}
		const collectionId = requestParameters.collectionId;
		if (collectionId === null || collectionId === undefined) {
			throw new Error('Required parameter collectionId was null or undefined when calling httpAssetsDeleteAll.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<any>(`${this.configuration.basePath}/assets`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsDeleteById(requestParameters: HttpAssetsDeleteByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<any>;
	public httpAssetsDeleteById(
		requestParameters: HttpAssetsDeleteByIdRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<any>>;
	public httpAssetsDeleteById(
		requestParameters: HttpAssetsDeleteByIdRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<any>>;
	public httpAssetsDeleteById(
		requestParameters: HttpAssetsDeleteByIdRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const id = requestParameters.id;
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsDeleteById.');
		}

		let headers = this.defaultHeaders;

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.delete<any>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, {
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsGet(requestParameters: HttpAssetsGetRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<AssetPageResult>;
	public httpAssetsGet(
		requestParameters: HttpAssetsGetRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<AssetPageResult>>;
	public httpAssetsGet(
		requestParameters: HttpAssetsGetRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<AssetPageResult>>;
	public httpAssetsGet(requestParameters: HttpAssetsGetRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' }): Observable<any> {
		const collectionid = requestParameters.collectionid;
		const collectiontypeid = requestParameters.collectiontypeid;
		const fields = requestParameters.fields;
		const expose = requestParameters.expose;
		const continuationToken = requestParameters.continuationToken;
		const limit = requestParameters.limit;
		const orderby = requestParameters.orderby;
		const filter = requestParameters.filter;
		const items = requestParameters.items;
		const translations = requestParameters.translations;
		const acceptLanguage = requestParameters.acceptLanguage;

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (collectionid !== undefined && collectionid !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>collectionid, 'collectionid');
		}
		if (collectiontypeid !== undefined && collectiontypeid !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>collectiontypeid, 'collectiontypeid');
		}
		if (fields !== undefined && fields !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>fields, 'fields');
		}
		if (expose !== undefined && expose !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>expose, 'expose');
		}
		if (continuationToken !== undefined && continuationToken !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>continuationToken, 'continuation_token');
		}
		if (limit !== undefined && limit !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>limit, 'limit');
		}
		if (orderby !== undefined && orderby !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>orderby, 'orderby');
		}
		if (filter !== undefined && filter !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>filter, 'filter');
		}
		if (items !== undefined && items !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>items, 'items');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.get<AssetPageResult>(`${this.configuration.basePath}/assets`, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint returns one single asset (from ID). If the returned asset is from a special asset type (e.g. \&quot;AssetImage\&quot;) it returns the full entity.
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsGetById(requestParameters: HttpAssetsGetByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' }): Observable<Asset>;
	public httpAssetsGetById(
		requestParameters: HttpAssetsGetByIdRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsGetById(
		requestParameters: HttpAssetsGetByIdRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsGetById(
		requestParameters: HttpAssetsGetByIdRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const id = requestParameters.id;
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsGetById.');
		}
		const fields = requestParameters.fields;
		const expose = requestParameters.expose;
		const items = requestParameters.items;
		const translations = requestParameters.translations;
		const acceptLanguage = requestParameters.acceptLanguage;

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (fields !== undefined && fields !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>fields, 'fields');
		}
		if (expose !== undefined && expose !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>expose, 'expose');
		}
		if (items !== undefined && items !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>items, 'items');
		}
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.get<Asset>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * This endpoint updates one single asset (from ID)
	 * @param requestParameters
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public httpAssetsUpdateById(
		requestParameters: HttpAssetsUpdateByIdRequestParams,
		observe?: 'body',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<Asset>;
	public httpAssetsUpdateById(
		requestParameters: HttpAssetsUpdateByIdRequestParams,
		observe?: 'response',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpResponse<Asset>>;
	public httpAssetsUpdateById(
		requestParameters: HttpAssetsUpdateByIdRequestParams,
		observe?: 'events',
		reportProgress?: boolean,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<HttpEvent<Asset>>;
	public httpAssetsUpdateById(
		requestParameters: HttpAssetsUpdateByIdRequestParams,
		observe: any = 'body',
		reportProgress: boolean = false,
		options?: { httpHeaderAccept?: 'application/json' }
	): Observable<any> {
		const id = requestParameters.id;
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling httpAssetsUpdateById.');
		}
		const asset = requestParameters.asset;
		if (asset === null || asset === undefined) {
			throw new Error('Required parameter asset was null or undefined when calling httpAssetsUpdateById.');
		}
		const translations = requestParameters.translations;
		const acceptLanguage = requestParameters.acceptLanguage;

		let queryParameters = new HttpParams({ encoder: this.encoder });
		if (translations !== undefined && translations !== null) {
			queryParameters = this.addToHttpParams(queryParameters, <any>translations, 'translations');
		}

		let headers = this.defaultHeaders;
		if (acceptLanguage !== undefined && acceptLanguage !== null) {
			headers = headers.set('Accept-Language', String(acceptLanguage));
		}

		let credential: string | undefined;
		// authentication (msal_auth) required
		credential = this.configuration.lookupCredential('msal_auth');
		if (credential) {
			headers = headers.set('Authorization', 'Bearer ' + credential);
		}

		let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
		if (httpHeaderAcceptSelected === undefined) {
			// to determine the Accept header
			const httpHeaderAccepts: string[] = ['application/json'];
			httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
		}
		if (httpHeaderAcceptSelected !== undefined) {
			headers = headers.set('Accept', httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ['application/json'];
		const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected !== undefined) {
			headers = headers.set('Content-Type', httpContentTypeSelected);
		}

		let responseType_: 'text' | 'json' = 'json';
		if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
			responseType_ = 'text';
		}

		return this.httpClient.post<Asset>(`${this.configuration.basePath}/assets/${encodeURIComponent(String(id))}`, asset, {
			params: queryParameters,
			responseType: <any>responseType_,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}
}
